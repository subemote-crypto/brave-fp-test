<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8" />
    <title>Brave Farbling Verifier 3</title>
    <style>
        /* ãƒ¦ãƒ¼ã‚¶ãƒ¼æŒ‡å®šé€šã‚Šã€æ–‡å­—ã‚µã‚¤ã‚ºã¯å¤‰æ›´ã—ãªã„ï¼ˆå…ƒã®html font-sizeã‚’ç¶­æŒï¼‰ */
        html { font-size: 150%; } /* æ—¢å­˜ã®è¨­å®šã‚’ä¿æŒ */

        body {
            font-family: monospace;
            padding: 30px;
            background-color: #f4f4f4;
            font-size: 1rem;
        }
        h1 { color: #333; font-size: 1.4rem; }
        p { font-size: 0.9rem; }
        button {
            font-size: 0.75rem;
            padding: 10px 20px;
            margin-right: 15px;
            cursor: pointer;
        }
        #output {
            background-color: #fff;
            padding: 20px;
            border: 2px solid #ddd;
            white-space: pre-wrap;
            word-break: break-all;
            font-size: 0.8rem;
            -webkit-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
    </style>
</head>
<body>
    <h1>Brave Farbling Verifier 3 (æ”¹è‰¯ç‰ˆ)</h1>
    <p>Canvas / Audio / WebGL ã‚’ã‚ˆã‚Šç¢ºå®Ÿã«ãƒãƒƒã‚·ãƒ¥åŒ–ã—ã¦ã€Farbling ã®å¤‰åŒ–ã‚’æ¤œå‡ºã—ã¾ã™ã€‚æ–‡å­—ã‚µã‚¤ã‚ºã¯å¤‰æ›´ã—ã¦ã„ã¾ã›ã‚“ã€‚</p>

    <button id="run1">æ¸¬å®šé–‹å§‹ (1å›)</button>
    <button id="run3">æ¸¬å®šé–‹å§‹ (3å›é€£ç¶š)</button>
    <button id="copy">æ¸¬å®šçµæœã‚’ã‚³ãƒ”ãƒ¼</button>
    <hr>

    <h2>æ¸¬å®šçµæœãƒ­ã‚°</h2>
    <pre id="output">æ¸¬å®šãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ãã ã•ã„...</pre>

    <script>
    // ãƒ˜ãƒ«ãƒ‘: ArrayBuffer -> hex
    function bufToHex(buffer) {
        const hex = Array.from(new Uint8Array(buffer))
            .map(b => b.toString(16).padStart(2,'0'))
            .join('');
        return hex;
    }

    // --- Canvas: getImageData ã‚’ SHA-256 ã§ãƒãƒƒã‚·ãƒ¥åŒ– ---
    async function getCanvasFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            // å°‘ã—é«˜ã•ã‚’å¢—ã‚„ã—ã¦ã€è¤‡æ•°æç”»ã‚’ç¢ºä¿
            canvas.width = 600;
            canvas.height = 120;
            ctx.clearRect(0,0,canvas.width,canvas.height);

            ctx.textBaseline = "top";
            ctx.font = "24px 'Arial', sans-serif";
            ctx.fillStyle = "#f60";
            ctx.fillRect(100, 1, 160, 40);

            ctx.shadowBlur = 4;
            ctx.shadowColor = "rgba(0, 0, 0, 0.5)";

            ctx.fillStyle = "#069";
            ctx.fillText("Brave Farbling Test ğŸš€ - Verifier 3", 10, 28);

            ctx.shadowBlur = 0;
            ctx.fillStyle = "#333";
            ctx.font = "16px monospace";
            ctx.fillText("canvas", 5, 5);

            // ç”Ÿãƒ”ã‚¯ã‚»ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ï¼ˆåœ§ç¸®ã«ã‚ˆã‚‹æºã‚‰ãã‚’æ’é™¤ï¼‰
            const img = ctx.getImageData(0,0, canvas.width, canvas.height);
            // ã‚¤ãƒ¡ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚¤ãƒˆåˆ—ã‚’ç›´æ¥ãƒãƒƒã‚·ãƒ¥
            const hashBuf = await crypto.subtle.digest('SHA-256', img.data.buffer);
            return bufToHex(hashBuf);
        } catch (e) {
            console.error('Canvas error', e);
            return "Canvas_Error";
        }
    }

    // --- Audio: AnalyserNode ã‹ã‚‰è¤‡æ•°ãƒ•ãƒ¬ãƒ¼ãƒ ã‚’å–å¾—ã—ã¦çµåˆã— SHA-256 ---
    async function getAudioFingerprint() {
        try {
            // å®‰å®šåŒ–ã®ãŸã‚ resume ã‚’ç¢ºå®Ÿã«è©¦ã¿ã‚‹
            const Ctx = window.AudioContext || window.webkitAudioContext;
            if (!Ctx) return "Audio_Not_Available";

            const audioCtx = new Ctx({ sampleRate: 44100 });
            await (audioCtx.state === 'running' ? Promise.resolve() :
                   (audioCtx.resume ? audioCtx.resume() : Promise.resolve()));

            const oscillator = audioCtx.createOscillator();
            oscillator.type = 'sine';
            oscillator.frequency.setValueAtTime(440, audioCtx.currentTime);

            const analyser = audioCtx.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.5;

            oscillator.connect(analyser);
            oscillator.start();

            // æ™‚é–“é ˜åŸŸãƒ‡ãƒ¼ã‚¿ã‚’è¤‡æ•°å›å–å¾—ï¼ˆå³åº§ã«1å›ã§ã¯å®‰å®šã—ãªã„å¯èƒ½æ€§ã‚ã‚Šï¼‰
            const frames = 4;
            const collected = new Float32Array(analyser.fftSize * frames);
            const tmp = new Float32Array(analyser.fftSize);
            for (let i=0;i<frames;i++){
                analyser.getFloatTimeDomainData(tmp);
                collected.set(tmp, i * analyser.fftSize);
                // çŸ­ã„ã‚¦ã‚§ã‚¤ãƒˆï¼ˆUI ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„ç¨‹åº¦ï¼‰
                await new Promise(r => setTimeout(r, 10));
            }

            oscillator.stop();
            audioCtx.close();

            // Float32Array ã®ãƒã‚¤ãƒˆåˆ—ã‚’ãƒãƒƒã‚·ãƒ¥
            const hashBuf = await crypto.subtle.digest('SHA-256', collected.buffer);
            return bufToHex(hashBuf);
        } catch (e) {
            console.error('Audio error', e);
            return "Audio_Error";
        }
    }

    // --- WebGL: è¤‡æ•°ãƒ”ã‚¯ã‚»ãƒ« + getParameter ã‚’çµåˆã—ã¦ SHA-256 ---
    async function getWebGLFingerprint() {
        try {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
            if (!gl) return "WebGL_Not_Available";

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT);

            // readPixels æ•°ã‚«æ‰€
            const pixels = new Uint8Array(4 * 9); // 9 ãƒ”ã‚¯ã‚»ãƒ«åˆ†
            const coords = [
                [0,0],[1,1],[2,2],[3,3],[4,4],[5,5],[6,6],[7,7],[8,8]
            ];
            let offset = 0;
            for (const [x,y] of coords) {
                const tmp = new Uint8Array(4);
                try {
                    gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, tmp);
                } catch(e) {
                    // readPixels ãŒå¤±æ•—ã™ã‚‹ç’°å¢ƒãŒã‚ã‚‹
                }
                pixels.set(tmp, offset);
                offset += 4;
            }

            // ä¸»è¦ãª getParameter æƒ…å ±ã‚‚å–å¾—
            const params = [
                gl.getParameter(gl.VENDOR),
                gl.getParameter(gl.RENDERER),
                gl.getParameter(gl.VERSION),
                gl.getParameter(gl.SHADING_LANGUAGE_VERSION)
            ].map(v => (v || '').toString()).join('|');

            // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ–‡å­—åˆ—ã¨ãƒ”ã‚¯ã‚»ãƒ«ãƒã‚¤ãƒˆåˆ—ã‚’çµåˆã—ã¦ãƒãƒƒã‚·ãƒ¥
            const enc = new TextEncoder();
            const paramsBuf = enc.encode(params);

            // combine buffers
            const combined = new Uint8Array(paramsBuf.byteLength + pixels.byteLength);
            combined.set(new Uint8Array(paramsBuf), 0);
            combined.set(pixels, paramsBuf.byteLength);

            const hashBuf = await crypto.subtle.digest('SHA-256', combined.buffer);
            return bufToHex(hashBuf);
        } catch (e) {
            console.error('WebGL error', e);
            return "WebGL_Error";
        }
    }

    // --- å®Ÿè¡Œï¼è¡¨ç¤ºãƒ­ã‚¸ãƒƒã‚¯ï¼ˆéåŒæœŸå¯¾å¿œï¼‰ ---
    async function sampleFingerprint() {
        const fp = {};
        fp.ts = (new Date()).toISOString();

        // ä¸¦åˆ—å®Ÿè¡Œã—ã¦é«˜é€ŸåŒ–ï¼ˆãŸã ã—ãƒ–ãƒ©ã‚¦ã‚¶ãŒåŒæ™‚ã«å‡¦ç†ã™ã‚‹ãŸã‚é †åºã¯ä¸å®šï¼‰
        const [canvasH, audioH, webglH] = await Promise.all([
            getCanvasFingerprint(),
            getAudioFingerprint(),
            getWebGLFingerprint()
        ]);

        fp.canvas_hash = canvasH;
        fp.audio_hash = audioH;
        fp.webgl_hash = webglH;
        fp.hardwareConcurrency_masked = window.navigator.hardwareConcurrency || 'unknown';
        fp.deviceMemory_masked = window.navigator.deviceMemory || 'unknown';
        return fp;
    }

    // ãƒ­ã‚°ç®¡ç†
    const log = [];
    const outputEl = document.getElementById('output');

    async function runTestAndDisplay(note, repeats=1, delayMs=150) {
        log.length = 0;
        for (let i=0;i<repeats;i++){
            const fp = await sampleFingerprint();
            fp.note = repeats===1 ? note : `${note} (${i+1}/${repeats})`;
            log.push(fp);
            // è»½ã„é…å»¶
            if (i < repeats-1) await new Promise(r => setTimeout(r, delayMs));
        }
        renderOutput();
    }

    function renderOutput() {
        let outputText = `--- ${document.title} ---`;
        log.forEach((entry, index) => {
            outputText += `\n\n[${index + 1}] ${entry.note}\n`;
            outputText += `  æ—¥æ™‚: ${entry.ts}\n`;
            outputText += `  Canvas SHA-256: ${entry.canvas_hash}\n`;
            outputText += `  Audio SHA-256: ${entry.audio_hash}\n`;
            outputText += `  WebGL SHA-256: ${entry.webgl_hash}\n`;
            outputText += `  CPU Cores: ${entry.hardwareConcurrency_masked}\n`;
            outputText += `  RAM (GB): ${entry.deviceMemory_masked}\n`;
        });
        outputEl.innerText = outputText;
    }

    document.getElementById('run1').addEventListener('click', () => runTestAndDisplay('Single Measurement', 1));
    document.getElementById('run3').addEventListener('click', () => runTestAndDisplay('Triple Measurement', 3, 250));
    document.getElementById('copy').addEventListener('click', async () => {
        const text = outputEl.innerText;
        if (!navigator.clipboard) {
            alert('ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰APIãŒã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚');
            return;
        }
        try {
            await navigator.clipboard.writeText(text);
            alert('æ¸¬å®šçµæœã‚’ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼ã—ã¾ã—ãŸï¼');
        } catch (e) {
            console.error('ã‚³ãƒ”ãƒ¼å¤±æ•—', e);
            alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
        }
    });
    </script>
</body>
</html>
